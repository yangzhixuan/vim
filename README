" vim: foldmethod=marker
"general settings {{{
    set number
    set scrolloff=1
    set incsearch
    set hlsearch

    "enhanced completion in cmd line
    set wildmenu

    set shiftwidth=4
    set tabstop=4
    set expandtab
    set smarttab

    set autoread
    set smartindent
    set autowrite
    syntax on

    set mouse=a

    set cursorline
    set display+=lastline

    "highlight the 80th char in a line
    highlight rightMargin term=bold ctermfg=red
    match rightMargin /\%<81v.\%>80v/

    set foldmethod=syntax
    set foldlevelstart=99
    filetype indent plugin on

    "speed up external commands by skipping the .zshrc
    set shell=/bin/zsh\ -f
"}}}

"dictionary completion <C-X><C-K> {{{
    set dictionary+=/usr/share/dict/cracklib-small
    set iskeyword+=-
"}}}

"forget-those {{{
    inoremap <ESC> <NOP>
"}}}
"
"shortcuts {{{
    let mapleader = ","
    let localleader = "\\"

    nnoremap <F5> :make<CR>

    if has("gui_running") "{{{
        noremap <A-q> :NERDTreeToggle<CR>
    else
        "Explanation: I want to use <A-q> as NERDTree, but my xfce-terminal modified
        "the key sequence(learn more in help :map-alt-keys), so I have to use <C-v><A-q>.
        noremap q :NERDTreeToggle<CR>
    endif "}}}

    "use <space> to open or close folds
    nnoremap <SPACE> za

    "n/v/o mode mappings {{{
        noremap H ^
        noremap L $
        noremap Y y$
    "}}}

    "normal mode mappings {{{
        nnoremap \ gt
        nnoremap <tab> gT
        nnoremap <C-b>n  :bnext<CR>
        nnoremap <C-b>p  :bprev<CR>
        nnoremap <leader>q :q<CR>

        nnoremap <C-a> ggVG"+y
        nnoremap <C-n> :tabnew<SPACE>
        nnoremap <C-l> :nohlsearch<CR>
        nnoremap <C-h> :help<SPACE>
        nnoremap _ ddkP
        nnoremap - ddp
        nnoremap <leader>rc :vsp $MYVIMRC<CR>
        nnoremap <leader>src :source $MYVIMRC<CR>
        nnoremap <leader>o o<ESC>k
        nnoremap <leader><space> a<space><ESC>

        nnoremap <C-?> ?\v
        "it's <C-/> actually
        nnoremap  /\v

        "gj and gk work better when a long line is wrapped
        nnoremap j gj
        nnoremap k gk
    "}}}

    "insert mode mappings {{{
        inoremap jk <esc>
        inoremap <C-Z> <ESC>zza
        inoremap <C-u> <ESC>mzgUiw`za

        "make <C-c> trigger LeaveInsert autocmd event
        inoremap <C-c> <ESC>
    "}}}

    "surround the word {{{
        nnoremap <leader>" viw<esc>a"<esc>hbi"<esc>lel
        nnoremap <leader>( viw<esc>a)<esc>hbi(<esc>lel
        vnoremap <leader>" <esc>`>a"<esc>`<i"<esc>
        vnoremap <leader>( <esc>`>a)<esc>`<i(<esc>
    "}}}

    "operator-pending mappings {{{
        "these motions are very similar to the defaul i( or i" motions, but they
        "allow you to select the block when the cousor is outside the block.
        "So, they are called i(nner) n(ext)/l(ast) (/"
        onoremap in( :<C-u>normal! f(vi(<CR>
        onoremap il( :<C-u>normal! F)vi(<CR>
        onoremap in" :<C-u>normal! f"vi"<CR>
        onoremap il" :<C-u>normal! F"vi"<CR>
    "}}}

    "quickfix mappings {{{
        nnoremap <leader>n :cnext<CR>
        nnoremap <leader>p :cprev<CR>
        nnoremap <leader>co :cwin<CR>
        nnoremap <leader>cc :cclose<CR>
    "}}}
"}}}

"smooth scroll {{{
    nnoremap <C-U> <C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y>
    nnoremap <C-D> <C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E>
"}}}

"pathogen {{{
    runtime bundle/vim-pathogen/autoload/pathogen.vim
    call pathogen#infect()
"}}}

"powerline {{{
    set nocompatible
    set t_Co=256
    let g:Powerline_symbols = 'fancy'
    set guifont=Monaco\ for\ Powerline
    set laststatus=2
"}}}

"ctrlp {{{
    set runtimepath^=~/.vim/bundle/ctrlp.vim
"}}}

"ruby {{{
    augroup rubyindent
        autocmd!
        autocmd FileType ruby set softtabstop=2 | set shiftwidth=2
    augroup END
"}}}

"javascript {{{
    augroup jscmd
        autocmd!
        "yes, I always forget semicons in js
        autocmd Filetype javascript,html inoremap <leader>kc <ESC>kA;<CR>
    augroup END
"}}}


"fcitx {{{
    let g:prev_status = 0
    function! Fcitx2en()
        let g:prev_status = system("fcitx-remote")
        if g:prev_status == 2
           call system("fcitx-remote -c")
        endif
    endfunction

    function! Fcitx2zh()
        if g:prev_status == 2
            call system("fcitx-remote -o")
        endif
    endfunction

    augroup fcitx_aucmd
        autocmd!
        autocmd InsertLeave * call Fcitx2en()
        autocmd InsertEnter * call Fcitx2zh()
    augroup END
"}}}

"html_preview {{{
    augroup html_aucmd
        autocmd!
        autocmd FileType html nnoremap <leader>fp :!firefox % <CR><CR>
    augroup END
"}}}

"c++/c autocmds {{{
    "Since I write single file programs most of the time, it's more convenient to
    "use g++/gcc directly as the makeprg
    function! SetMakeprg(compiler)
        let l:option = printf('setlocal makeprg=%s\ -lmicrohttpd\ %s\ -o\ %s', a:compiler, @%, fnamemodify(@%, ':t:r'))
        execute l:option
    endfunction

    augroup c_aucmd
        autocmd!
        autocmd FileType c call SetMakeprg("gcc")
        autocmd FileType cpp call SetMakeprg("g++")
    augroup END
"}}}

"show space as dot {{{
    set listchars=tab:â–¸\ ,trail:Â·
    set list
"}}}

"fold column toggle key {{{
    function! FoldColumnToggle()
        if &foldcolumn
            setlocal foldcolumn=0
        else
            setlocal foldcolumn=1
        endif
    endfunction
    nnoremap <leader>f :call FoldColumnToggle()<CR>
"}}}

"autocmds for scratch files{{{
    augroup scratch
        autocmd! 
        autocmd QuitPre * if @% == "" | setlocal nomodified | endif
    augroup END
"}}}
